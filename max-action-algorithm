Approach 1.

Returns the maximum ammount of decompositions of the task n given a Searchnode node
in an hierachical planning problem with (0 ... n_max) tasks and (0 ... m_max) methods).

Input: Searchnode - node; Task - task_x;

int task_x_maxValue = 0;

Queue producer
producer.push((noop(x),task_x,1))

//Every task can possible contribute to producing task_x
//The int value indicates how often task_x can be produced from the current task
//If the int value is -1 then it cant be calculated right away
//The list stores the possible decompositions
//For every decomposition we store the tasks with unkown contribution its corresponding list
//For every decomposition we store the amount of task_x that can be produced for certain in its corresponding int value

<int,list<int,list>> contribution
Array<contribution> contributions[task_1 ... task_n_max]
for(i: 0 ... n_max){
	contribution[task_i] = <0,null>
}
contribution[task_x]=<1,null>

while(producer != empty){
	(currM,currN,currY) = producer.pop

	//update contribution of task(currM)
	oldContribution[task(currM)] = <oldInt,oldList>		

	int newInt=0;
	list newList= {};
	for(subtask in subtask(currM){
		if(subtask==task_x){
			newInt+= 1
		if(contribution[subtask] == <z,null>){
			newInt +=z
		}else if(isAbstract(subtask)){
			newList.add(subtask)	
		}
	}
	if(newList != empty){
		oldInt = -1	
	}
	if(oldInt != -1) {
		contribution[task(currM)] = <max{newInt,oldInt},null>	
	}else{
		oldList.push(<newInt,newList>)
	}
		

	if(newListContribution == empty){
		contribution[task(currM)] = max{currY*contribution[task(currN)],contribution[task(currM)]}
	}else{
		
	}
	
	
	//consider additional producers
	for((m,x,n) in producer(task(currM))){
		//maybe check for cycles
		if(!producer.contains(m,x,n)){
			producer.push((m,x,n))
		}
    	}
}

for(task_i in containedTask(node){
	task_x_maxValue+=contribution[task_i];	
}

return task_x_maxValue

subtask(m) := multiset of subtasks that will be produced by method m

producer(n):= set of tuples (m,n,y) where the task_n can be produced y >=1 times as subtask of m.

task(m):= task that is decomposed in the method m.

containedTask(node) := multiset of tasks that are contained in the current searchnode 
If an task has x occurences in node it will be contained x times in the multiset.

noop(x) := dummy method that decomposes x into x

isAbstract(task) := true if task is an Abstract task, false otherwise

Approach 2.

Returns the maximum ammount of decompositions of the task n given a Searchnode node
in an hierachical planning problem with (0 ... n_max) tasks and (0 ... m_max) methods).
Nodes is a mulitset of tasks(can contain multiple instances of tasks).
boolNode is a multiset of tasks with a boolean Value for every task that indicates if the task has already been decomposed

Input: node - initialNode; Task - task_x;

int task_x_maxValue = 0;

Queue<boolNode> fringe
List<boolNode> leafs

boolNode initialBoolNode
for(task in initialNode){
	initialBoolNode.add(<task,false>)
}
fringe.push(initialBoolNode)

while(fringe != empty){
	curr = fringe.pop
	bool isLeaf=true
	for(<task,bool> in curr){
		if(isAbstract(task) && bool == false){
			for(currMethod in methods(task)){
				bool = true
				fringe.push(curr Union <subtask(currMethod),false>)
			}		
			isLeaf=false
		}	
	}
	if(isLeaf){
		leafs.add(curr)	
	}
}

for(leaf in leafs){
	task_x_maxValue=max(contains(leaf,task_x),task_x_maxValue)
}




isAbstract(task) := true if task is an Abstract task, false otherwise
methods(task) := set of methods that are applicable to task
subtask(method) := set of subtasks that will be produced by method

